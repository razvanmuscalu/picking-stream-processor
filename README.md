# Picnic Recruitment Task #

Please read the following instructions carefully and make sure that you fulfil
all requirements listed.

## Overview ##

This is a Java programming assignment we've created specifically for our
recruitment process. It's a [Maven][maven] project in a Git repository hosted
on GitHub. You were given a link to GitHub, which when you visited that link,
created a private fork of this repository. Only you and developers at Picnic
can see the code you push to this repository.

High-level instructions:
1. Read and follow the task specified below.
2. Make a local clone of this repository on your machine, and do your work on a
   branch other than `master`. Do not make any changes to the `master` branch.
3. Push your changes as frequently as you like to `origin/your-branch-name`,
   and create a pull request to merge your changes back into the `master`
   branch. Don't merge your pull request. Once you're finished with the
   assignment, we will do a code review of your pull request.
4. When you're finished, [create and add][github-labels] the label `done` to
   your pull request. This will notify us that your code is ready to be
   reviewed. Please do **NOT** publish your solution on a publicly available
   location (such as a public GitHub repository, your personal website, _et
   cetera_).

This process closely mimics our actual development and review cycle. We hope
you enjoy it!

## Provided Functionality ##

The provided code is structured as follows:
* Package `tech.picnic.assignment.api` contains classes that must **NOT** be
  modified. Of special interest in this package are the following two
  interfaces:
  * `EventProcessorFactory`: you will be asked to create an implementation of
    this interface; this implementation must be "[service
    loadable][service-loader]". Don't worry if you don't know what that means;
    the provided code comes with a skeleton implementation that already meets
    this criterion (see below).
  * `StreamProcessor`: most of the assignment revolves around creating an
    implementation of this interface which meets various criteria. The
    aforementioned factory should be able to create one or more of these
    processor instances.
* Package `tech.picnic.assignment.impl` contains a skeleton implementation of
  the aforementioned `EventProcessorFactory` interface. Your task is to change
  the code in this package to meet the criteria described below.
* The `pom.xml` file defines how [Maven][maven] can build the project. Some
  aspects of this file must not be changed; those are indicated using comments.
  Make sure that your project builds using `mvn clean install`.
* Under `src/test` a disabled test is defined. Consider getting it to pass ;).

## Context ##

In a nutshell, the assignment revolves around reading JSON events from an
`InputStream`, processing then, and writing the result to an `OutputStream`.

The input event stream comprises "pick events"; each of these events represents
the action of a warehouse employee fulfilling a customer order ("picking" an
item off a shelf).
- No assumptions should be made about the source of this event stream. Perhaps
  the events are read from a file, perhaps they arrive over a TCP stream from
  the other side of the world, or perhaps they are auto-generated by a test
  framework ;).
- No assumptions should be made about the speed at which events arrive.
  Multiple events may arrive in brief succession, but it could also be that no
  events arrive for extended periods of time.
- Each event adheres to the JSON format described below.
- Each event comprises a single line of JSON.
- Events are separated by a newline ('\n').
- If no events are sent for a while, `keep-alive` messages consisting of a
  single `\n` may be sent.

### Pick event type specification

|  Field      | Type    | Description                                                                                        |
|:-----------:|:-------:|:--------------------------------------------------------------------------------------------------:|
| `id`        | String  | A unique identifier                                                                                |
| `timestamp` | String  | The time at which the event was emitted; formatted as an [ISO 8601][iso-8601] UTC date-time string |
| `picker`    | Object  | Picker object, see below                                                                           |
| `article`   | Object  | Article object, see below                                                                          |
| `quantity`  | Integer | The number of articles picked                                                                      |

### Picker type specification

| Field           | Type   | Description                                                                                                |
|:---------------:|:------:|:----------------------------------------------------------------------------------------------------------:|
| `id`            | String | A unique identifier                                                                                        |
| `name`          | String | The person's name                                                                                          |
| `active_since`  | String | The time the picker clocked in to start working; formatted as an [ISO 8601][iso-8601] UTC date-time string |

### Article type specification

| Field              | Type   | Description                     |
|:------------------:|:------:|:-------------------------------:|
| `id`               | String | A unique identifier             |
| `name`             | String | An English, human-readable name |
| `temperature_zone` | String | Either `ambient` or `chilled`   |

### Example input event JSON representation

The following JSON object is an example of the kind of event that may be
received from the `InputStream`. Note how it matches the specification above.
There is one difference: you may assume that the events read from the
`InputStream` comprise a single line. (I.e., they are not formatted.)

```json
{
  "timestamp": "2018-12-20T11:50:48Z",
  "id": "2344",
  "picker": {
    "id": "14",
    "name": "Joris",
    "active_since": "2018-12-20T08:20:15Z"
  },
  "article": {
    "id": "13473",
    "name": "ACME Bananas",
    "temperature_zone": "ambient"
  },
  "quantity": 2
}
```

## Task ##

We would like you to create a pull request that implements the functionality
listed below.

* An `EventProcessorFactory` implementation which produces `StreamProcessor`s
  capable of reading the event stream described above.
* The factory must be [service loadable][service-loader]. (The provided
  `PickingEventProcessorFactory` already meets this criterion through use of
  the `@AutoService` annotation.)
* The factory should produce processors that respect the given `maxEvents` and
  `maxTime` parameters. For example,
  `myEventProcessorFactory.createProcessor(100, Duration.ofSeconds(30))` should
  produce a `StreamProcessor` which for every invocation of
  `StreamProcessor#process` returns after reading at most 100 events or after
  30 seconds, whichever condition is met first.
* A processor should process the events it receives as follows:
  - Only pick events corresponding to picks of `ambient` articles are retained.
    (Picks of chilled articles do count towards the `maxEvents` limit but are
    otherwise ignored.)
  - Events must be grouped by `picker`.
  - Pickers must be sorted chronologically (ascending) by their `active_since`
    timestamp, breaking ties by ID.
  - The picks per picker must also be sorted chronologically, ascending. (Note
    that events may not _arrive_ in chronological order!)
  - The article names should be capitalized.
* A processor must write the result of the aforementioned filter, group and
  sort operations to the provided `OutputStream` according the following JSON
  format:
  ```json
  [
    {
      "picker_name": "Joris",
      "active_since": "2018-09-20T08:20:00Z",
      "picks": [
        {
          "article_name": "ACME BANANAS",
          "timestamp": "2018-12-20T11:50:48Z"
        },
        ... more picks here ...
      ]
    },
    ... more pickers here ...
  ]
  ```

For a complete example of expected input and corresponding output, compare the
contents of the following two provided files:
- [`happy-path-input.json-stream`](./src/test/resources/tech/picnic/assignment/impl/happy-path-input.json-stream)
- [`happy-path-output.json`](./src/test/resources/tech/picnic/assignment/impl/happy-path-output.json)

## Notes ##

* Feel free to add/modify dependencies in `pom.xml`.
* Do **not** modify the plugin configurations in `pom.xml`.
* Do **not** modify the `tech.picnic.assignment.api` package.

## Tips ##

* We value clean, readable, modern, and idiomatic Java. Your code will be
  reviewed by other developers, so make sure it is easy to follow and
  well-structured.
* Avoid doing manual JSON parsing. It's prone to errors and hard to read.
* Don't feel the need to over-engineer your solution. We don't expect you to
  build an entire system that can scale to billions of events. Your solution
  should be tailored to the problem statement. We prefer concise and simple
  solutions over lengthy ones. However, it should be straightforward to let the
  program behave differently, such as have a different timeout, filter on a
  different temperature zone, etc...
* It should really not be necessary to write more than, say, 500 lines of
  non-test code. (And in fact, it is possible to write a "perfect" solution
  using much less code than that.)

[iso-8601]: https://en.wikipedia.org/wiki/ISO_8601
[maven]: https://maven.apache.org
[service-loader]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html
[github-labels]: https://help.github.com/articles/about-labels
